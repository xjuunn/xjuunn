[toc]

# 前端性能优化

核心：加载更快、渲染更快

## 加载性能优化

### 减少资源体积

* 使用压缩或者打包工具，进行**代码压缩**，移除不必要的空格、注释、换行符等，缩短变量名。

* 使用打包工具分割代码，将代码分成多个小块；**按路由拆分**，每个路由加载各自的代码，避免首屏加载不必要的代码；**动态导入**，使用`import()`语法再需要时再加载模块。

* Tree Shaking：移除上下文中未引用的代码。

* 优化图像：选择合适的格式

  * Webp：同等质量下体积比jpeg/png小很多。注意兼容性。
  * avif：比webp更先进的格式，压缩率更高。
  * svg：用于图标和矢量图形，可无限缩放且体积小。
  * jpeg：适用于色彩丰富的图片，照片。
  * png：适用于需要透明度的图标，图形。

  图片懒加载

* 再服务器开启Gzip/Brotli，对文本资源进行压缩

### 减少网络请求次数

* 捆绑文件，将多个小文件合并成一个大文件，减少HTTP请求次数
* 资源提示
  * 预连接：提前于第三方源建立连接。
  * DNS预获取：提前解析DNS。
  * 预获取：在浏览器空闲时下载未来可能用到的资源。
  * 预加载：以高优先级下载当前页面必定需要的核心资源。可以提前加载关键CSS/字体。
* 利用浏览器**缓存**
  * 强缓存：通过设置`Cache-Control` 和`Expires`头，让浏览器直接使用本地缓存，不发送请求。
  * 协商缓存：通过`ETag`和`Last-modified`头，浏览器会发送请求，服务器验证资源未改变后返回3044，使用本地缓存。
  * 策略：为不常变化的静态资源设置长期缓存，为HTML设置`no-cache`或较短的最大存活时间。
* 优化网络路径
  * 使用CND：将静态资源分发到全球各地的边缘节点，使用户可以从地理上最近的服务器获取资源，降低网络延迟。
  * 升级HTTP/2或HTTP/3
    * HTTP/2：支持多路复用、服务器推送、头部压缩等特性，极大地提升了性能。
    * HTTP/3：基于QUIC协议，进一步解决了队头阻塞问题，连接建立更快，在丢包和网络切换场景下表现更优。

## 渲染性能优化

* 关键渲染路径优化
  * 优化CSS：将首屏内容所需样式直接内嵌在head中，避免为渲染首屏内容而等待外部CSS文件，减少FCP时间。避免CSS`@import`，`@import`会在HTML解析到该标签时才会加载，会阻止并行下载。
  * 优化JavaScript：将非关键JS延迟(Defer)，使用defer属性或async异步加载脚本，避免阻塞HTML解析。
  * 避免长任务：将大型计算人任务拆分为小块，使用`setTimeout`或`requestIdleCallback`在空闲时执行，或使用Web Worker在后台线程执行，避免阻塞主线程。
  * 优化字体：使用`font-display: swap`让文字在字体加载完成前先显示系统字体，加载后在切换；预加载关键字体。
* JavaScript执行效率
  * 避免**内存泄漏**：及时解除时间监听、清除定时器、便面意外的全局变量引用。
  * 使用**事件委托**：将监听器附加到父元素，利用事件冒泡处理子元素的事件，减少内存中的事件监听器数量。
  * **节流和防抖**：对于`resize`、`scroll`、`input`等高频触发的事件，使用节流或防抖事件处理函数的执行频率。
* 布局和绘制
  * 避免轻质同步布局：避免连续的读写样式
  * 减少重绘和重排：使用`transform`和`opacity`来做动画，他们由合成器处理，不触发布局和绘制；使用`visibility`替代`display:none`，前者只引起重绘，后者引起重排。谨慎使用CSS表达式。
  * 提升为合成层：对需要频繁变化的元素使用`will-change:transform;`或`transform:translateZ(0);`，浏览器只会将其提升到一个独立的合成层，由GPU加速处理，避免影响其他层。

