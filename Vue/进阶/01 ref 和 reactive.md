[toc]

# ref 和 reactive

| 特性       | ref                                  | reactive                             |
| ---------- | ------------------------------------ | ------------------------------------ |
| 数据类型   | 处理所有的类型                       | 仅处理对象类型                       |
| 访问方式   | 通过`.value`访问或修改               | 可以直接访问和修改属性               |
| 响应式丢失 | 赋值整个value对象不会丢失响应式      | 直接解构或者赋值整个对象会丢失响应式 |
| 模板中     | 在模板中会自动解包，无需使用`.value` | 在模板中直接访问属性                 |
| 类型       | Ref\<T\>                             | 本身类型                             |

> [!warning]
>
> ### reactive 的局限性
>
> 1. 有限的值类型：它只能用于对象类型(对象、数组和如Map，Set这样的集合类型)。它不能持有如string，number或boolean这样的原始类型
> 2. 不能替换整个对象：由于Vue的响应式跟踪式通过属性访问实现的，因此必须始终保持响应对象的相同引用。
> 3. 对结构操作不友好：将响应式对象的原始类型属性结构为本地变量时，或者将属性传递给函数时，响应式丢失。
>
> **所以更推荐ref作为响应式的主要api**

## 解决reactive解构失去响应式的问题

~~~ ts
const state = reactive({ count:0, name:'vue' });
let { count, name } = toRefs(state); // 使用toRefs将响应式对象的每个属性转换成一个ref
~~~

